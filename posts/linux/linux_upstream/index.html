<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="dark">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How I Upstreamed My First Linux Kernel Patch | Portfolio</title>
<meta name="keywords" content="">
<meta name="description" content="Everything and Everyone wants in on open source these days — maybe you do too.
This article is my attempt at articulating how I upstreamed my first kernel patch.
Let’s get started with a bit of background.
Background
I was writing a driver for work and I wanted to use i2c_transfer
in a function to write some data on an I2C bus.
In brief, that function gets a handle to an I2C bus and executes the commands specified in msgs. Therefore, the struct i2c_msg struct should specify if the command is a read or a write.">
<meta name="author" content="">
<link rel="canonical" href="https://craftychimera.github.io/posts/linux/linux_upstream/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.381f2c6843b28da8454ae291f64a45a8b239486456ac64a400ac43b398f8defe.css" integrity="sha256-OB8saEOyjahFSuKR9kpFqLI5SGRWrGSkAKxDs5j43v4=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://craftychimera.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://craftychimera.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://craftychimera.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://craftychimera.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://craftychimera.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://craftychimera.github.io/posts/linux/linux_upstream/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://craftychimera.github.io/posts/linux/linux_upstream/">
  <meta property="og:site_name" content="Portfolio">
  <meta property="og:title" content="How I Upstreamed My First Linux Kernel Patch">
  <meta property="og:description" content="Everything and Everyone wants in on open source these days — maybe you do too. This article is my attempt at articulating how I upstreamed my first kernel patch.
Let’s get started with a bit of background.
Background I was writing a driver for work and I wanted to use i2c_transfer in a function to write some data on an I2C bus.
In brief, that function gets a handle to an I2C bus and executes the commands specified in msgs. Therefore, the struct i2c_msg struct should specify if the command is a read or a write.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-11-17T11:50:00+05:30">
    <meta property="article:modified_time" content="2025-11-17T11:50:00+05:30">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="How I Upstreamed My First Linux Kernel Patch">
<meta name="twitter:description" content="Everything and Everyone wants in on open source these days — maybe you do too.
This article is my attempt at articulating how I upstreamed my first kernel patch.
Let’s get started with a bit of background.
Background
I was writing a driver for work and I wanted to use i2c_transfer
in a function to write some data on an I2C bus.
In brief, that function gets a handle to an I2C bus and executes the commands specified in msgs. Therefore, the struct i2c_msg struct should specify if the command is a read or a write.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://craftychimera.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Linux",
      "item": "https://craftychimera.github.io/posts/linux/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "How I Upstreamed My First Linux Kernel Patch",
      "item": "https://craftychimera.github.io/posts/linux/linux_upstream/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How I Upstreamed My First Linux Kernel Patch",
  "name": "How I Upstreamed My First Linux Kernel Patch",
  "description": "Everything and Everyone wants in on open source these days — maybe you do too. This article is my attempt at articulating how I upstreamed my first kernel patch.\nLet’s get started with a bit of background.\nBackground I was writing a driver for work and I wanted to use i2c_transfer in a function to write some data on an I2C bus.\nIn brief, that function gets a handle to an I2C bus and executes the commands specified in msgs. Therefore, the struct i2c_msg struct should specify if the command is a read or a write.\n",
  "keywords": [
    
  ],
  "articleBody": "Everything and Everyone wants in on open source these days — maybe you do too. This article is my attempt at articulating how I upstreamed my first kernel patch.\nLet’s get started with a bit of background.\nBackground I was writing a driver for work and I wanted to use i2c_transfer in a function to write some data on an I2C bus.\nIn brief, that function gets a handle to an I2C bus and executes the commands specified in msgs. Therefore, the struct i2c_msg struct should specify if the command is a read or a write.\nThere is indeed a flag that describes if the command is a read but there was no way to identify if it’s a write.\nThis is a pretty important API since I2C transactions are very common in embedded dev.\nAfter digging through code that used i2c_transfer to write data, I learnt that not setting I2C_M_RD is the way to describe the transaction as a write. Here’s an example.\nSince making this explicit is better than having this behavior undocumented, I decided to do that. I figured the best way of doing this was to update the description of I2C_M_RD.\nThis was not a very major change but the contribution workflow itself is not straightforward.\nLet me elaborate on that with some theory of how the kernel development process works.\nTheory Unlike most FOSS projects that have the contributors submit their changes via PRs, the Linux kernel uses mail. A contributor has to mail their patches to the relevant maintainers and mailing lists who will review and comment on the patches.\nIf you don’t know what a patch is, it’s just a commit stored in a text file making it suitable for mail.\nIf the patch stands this scrutiny, it gets merged into the subsystem’s fork of the repo. During the merge window (which will be discussed later), these changes become part of mainline (Linus’ fork) and if the patch is a bug fix, it gets into stable and is backported if significant enough.\nIt’s important to note that patches should be of a reasonable quality if they are to get upstreamed (become part of mainline). Even high-profile incidents, like the scandal involving the University of Minnesota were not as successful as one might assume.\nNow that we have the brief overview, let me go further in detail on the process.\nThe Kernel Development Process This section will just be a very brief summary of the Linux development process. For further reading, please consult the official documentation.\nThe Kernel Release Cycle The kernel uses a rolling development model. At the beginning of each development cycle, the merge window is opened. This is when maintainers forward feature patches to Linus. The bulk of major changes for a new development cycle will be merged during this time.\nThe merge window lasts for approximately two weeks. At the end of this time, Linus Torvalds will declare that the window is closed and release the first of the “rc” kernels. For the kernel destined to be v6.16 (current kernel as of the time of writing), this would be designated as v6.16-rc1. The -rc1 release is the signal that the time to merge new features has passed, and that the time to stabilize the next kernel has begun.\nOver the next six to ten weeks, only bug fix patches should be submitted to the mainline. As fixes make their way into the mainline, the patch rate will slow over time. Linus releases new -rc kernels about once a week; a normal series will get up to somewhere between -rc6 and -rc9 before the kernel is considered to be sufficiently stable and the final release is made.\nThe most significant metric used to determine if the kernel is stable enough is the list of regressions from previous releases. At that point the whole process starts over again.\nHow Patches get into the Kernel The kernel code base is logically broken down into subsystems: networking, memory management, drm, etc.\nMost subsystems have designated maintainer(s), developer(s) who has/have the overall responsibility for the code within that subsystem.\nThese subsystem maintainers are the gatekeepers for the portion of the kernel they manage; they are the ones who will accept a patch for inclusion into the mainline kernel.\nWhen the merge window opens, the top-level maintainers will ask Linus to “pull” the patches they have selected for merging from their repositories.\nWith that info in mind, let’s see how a patch is created and mailed.\nConfiguration SMTP Configuration Please refer to this link to setup an app password.\nThis password will be necessary when sending the mail with git send-email.\nYou could use a non Google SMTP server but I do not know how they work.\nGit Configuration Before starting, I would highly suggest you to configure your git username and email via\ngit config user.name \"Your Name\" git config user.email \"your.email@example.com\" You can check the config with\ngit config user.name # Prints user.name git config user.email # Prints user.email After you are setup with the configuration, clone Linus’ repo. You can do this via\ngit clone git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git # Linus' copy (mainline) Creating the patch Make the required changes and commit it, having the commit messages adhere to this format:\nsubsystem: brief summary of the change Then add a blank line, followed by a detailed explanation of the change. This is important because the first line will become the subject of the mail you will be sending.\nYou can check commits that have touched the file you want to understand what the commit should look like. This is done via:\ngit log -- See SubmittingPatches for more details.\nWhen you are about to commit, add the -s flag to the command. This adds a Signed-off-by line at the end of the commit.\nThis is required as per Developer Certificate of Origin.\nAssuming you have made n commits, create the patches by running\ngit format-patch HEAD~n A single patch should contain one logical change.\nAfter creating the patch(es), verify that it/they satisfies/satisfy the patch standards by running\n${LINUX_BASE}/scripts/checkpatch.pl ${PATCH} # do this for each patch in case of a patch series Note that your patch(es) should be as tested as thoroughly as possible if code was modified.\nI won’t be covering that aspect in this article.\nMailing the patch You need to figure out to whom the patch(es) need to be mailed to by running:\n${LINUX_BASE}/scripts/get_maintainer.pl ${FILE_MODIFIED} With that knowledge, It should be time to mail them.\nKeep in mind that the Linux Kernel Mailing Lists (lkml) expect you to mail in plaintext format which needs some setup. If you don’t do that, your mail will be rejected like this:\nI wouldn’t recommend mailing patches via Gmail directly.\nGit provides a dedicated command — git send-email — for sending emails in plain-text format.\nYou should use git send-email like this:\ngit send-email --to= --to= ... --cc= ... patch/patches This is the most basic command for mailing patches.\nAfter a maintainer takes interest in your patch, they add it to Patchwork which is where you can track the progress of your patch.\nPatchwork is a web-based patch tracking system that helps maintainers and contributors track the status of submitted patches, from review to acceptance and merging.\nHere’s how my attempts went.\nMy attempts Mailing a patch is just the beginning; You need to convince the maintainer that the patch is correct and necessary.\nIt’s a rather long process, and it’s quite common for you to get ghosted without warning if your patch isn’t proper which is what happened to me.\nAttempt 1 This was my patch.\nI threw in a second smaller patch because I believed that was just a free patch.\nI sent it there because I thought that’s where newbies sent their patches. And I was very wrong.\nI was thankfully redirected to linux-i2c@vger.kernel.org by one of the maintainers.\nI then submitted the patch there and waited.\nAttempt 2 Three months passed by and I realized that my patch would not be picked up.\nSo, It was time to go back to the drawing board. One of the first things I suspected was the subject of the patch.\nThe issue was “[PATCH] i2c: Update i2c_msg documentation to clarify write” was just too vague; That did not specify what exactly was changed. So, my solution was to change the title to “i2c: Clarify behavior of I2C_M_RD flag”. Here’s the submitted patch\nThis actually caught the attention of the maintainer and he was willing to accept it, if I signed with my legal name. I re-sent it almost immediately but then I made a really dumb mistake.\nAttempt 3 The thing is I sent the patch with improper threading.\nWithout the correct reply-to, the patch will not show up in the thread making it hard to understand the conversation.\nSo, After a few months of waiting, I realized something was wrong and realized my mistake.\nHere’s what the new command after adding reply-to looks like:\ngit send-email --in-reply-to=aCtgNpWs1tJ1FltB@shikoro --to=wsa+renesas@sang-engineering.com --cc=linux-i2c@vger.kernel.org --cc=viswanathiyyappan@gmail.com MY_REPLY If you click the reply hyperlink below a message, it actually provides you with the command\nThis led me to create my penultimate patch.\nI made a mistake missing the subject in the cover letter and corrected it here which was accepted.\nHere is my final accepted patch. The commit id for this patch in upstream is c3ff7f06c787\nClosing Remarks This particular patch is very minor compared to a bug fix or a feature patch. But this was good enough for a first patch.\nTo be clear, It usually does not take months to get a patch (especially of this complexity) in. I just didn’t know what I was doing.\nIn a way, getting your first patch in is the hardest.\nI hope this article has shed some light on the Linux contribution process and helped clarify things. Here are references for further reading:\nKernel Newbies Kernel Documentation Beginners Guide to Kernel Development The course explains the contribution process much better than this article.\nI would also suggest participating in the Linux Kernel Mentorship Program (https://wiki.linuxfoundation.org/lkmp) if this was interesting to you.\n",
  "wordCount" : "1688",
  "inLanguage": "en",
  "datePublished": "2025-11-17T11:50:00+05:30",
  "dateModified": "2025-11-17T11:50:00+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://craftychimera.github.io/posts/linux/linux_upstream/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Portfolio",
    "logo": {
      "@type": "ImageObject",
      "url": "https://craftychimera.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://craftychimera.github.io/" accesskey="h" title="Portfolio (Alt + H)">Portfolio</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://craftychimera.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://craftychimera.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://craftychimera.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://craftychimera.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://craftychimera.github.io/posts/linux/">Linux</a></div>
    <h1 class="post-title entry-hint-parent">
      How I Upstreamed My First Linux Kernel Patch
    </h1>
    <div class="post-meta"><span title='2025-11-17 11:50:00 +0530 IST'>17/11/2025</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>1688 words</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#background" aria-label="Background">Background</a></li>
                <li>
                    <a href="#theory" aria-label="Theory">Theory</a><ul>
                        
                <li>
                    <a href="#the-kernel-development-process" aria-label="The Kernel Development Process">The Kernel Development Process</a><ul>
                        
                <li>
                    <a href="#the-kernel-release-cycle" aria-label="The Kernel Release Cycle">The Kernel Release Cycle</a></li>
                <li>
                    <a href="#how-patches-get-into-the-kernel" aria-label="How Patches get into the Kernel">How Patches get into the Kernel</a></li></ul>
                </li>
                <li>
                    <a href="#configuration" aria-label="Configuration">Configuration</a><ul>
                        
                <li>
                    <a href="#smtp-configuration" aria-label="SMTP Configuration">SMTP Configuration</a></li>
                <li>
                    <a href="#git-configuration" aria-label="Git Configuration">Git Configuration</a></li></ul>
                </li>
                <li>
                    <a href="#creating-the-patch" aria-label="Creating the patch">Creating the patch</a></li>
                <li>
                    <a href="#mailing-the-patch" aria-label="Mailing the patch">Mailing the patch</a></li></ul>
                </li>
                <li>
                    <a href="#my-attempts" aria-label="My attempts">My attempts</a><ul>
                        
                <li>
                    <a href="#attempt-1" aria-label="Attempt 1">Attempt 1</a></li>
                <li>
                    <a href="#attempt-2" aria-label="Attempt 2">Attempt 2</a></li>
                <li>
                    <a href="#attempt-3" aria-label="Attempt 3">Attempt 3</a></li></ul>
                </li>
                <li>
                    <a href="#closing-remarks" aria-label="Closing Remarks">Closing Remarks</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Everything and Everyone wants in on open source these days — maybe you do too.
This article is my attempt at articulating how I upstreamed my first kernel patch.</p>
<p>Let’s get started with a bit of background.</p>
<h1 id="background">Background<a hidden class="anchor" aria-hidden="true" href="#background">#</a></h1>
<p>I was writing a driver for work and I wanted to use <a href="https://elixir.bootlin.com/linux/latest/source/drivers/i2c/i2c-core-base.c#L2279">i2c_transfer</a>
in a function to write some data on an I2C bus.</p>
<p>In brief, that function gets a handle to an I2C bus and executes the commands specified in msgs. Therefore, the struct <a href="https://elixir.bootlin.com/linux/v6.15.6/source/include/uapi/linux/i2c.h#L73">i2c_msg struct</a> should specify if the command is a read or a write.</p>
<p>There is indeed a flag that describes if the command is a read but there was no way to identify if it&rsquo;s a write.</p>
<p>This is a pretty important API since I2C transactions are very common in embedded dev.</p>
<p>After digging through code that used i2c_transfer to write data, I learnt that not setting I2C_M_RD is the way to describe the transaction as a write. Here&rsquo;s an <a href="https://elixir.bootlin.com/linux/v6.15.6/source/drivers/iio/accel/mma9551_core.c#L142">example</a>.</p>
<p>Since making this explicit is better than having this behavior undocumented, I decided to do that. I figured the best way of doing this was to update the description of I2C_M_RD.</p>
<p>This was not a very major change but the contribution workflow itself is not straightforward.</p>
<p>Let me elaborate on that with some theory of how the kernel development process works.</p>
<hr>
<h1 id="theory">Theory<a hidden class="anchor" aria-hidden="true" href="#theory">#</a></h1>
<p>Unlike most FOSS projects that have the contributors submit their changes via PRs, the Linux kernel uses mail. A contributor has to mail their
patches to the relevant maintainers and mailing lists who will review and comment on the patches.</p>
<p>If you don&rsquo;t know what a patch is, it&rsquo;s just a commit stored in a text file making it suitable for mail.</p>
<p>If the patch stands this scrutiny, it gets merged into the subsystem&rsquo;s fork of the repo. During the merge window (which will be discussed later), these changes become part of mainline (Linus&rsquo; fork) and if the patch is a bug fix, it gets into stable and is backported if significant enough.</p>
<p>It&rsquo;s important to note that patches should be of a reasonable quality if they are to get upstreamed (become part of mainline). Even high-profile incidents, like the <a href="https://cse.umn.edu/cs/linux-incident">scandal involving the University of Minnesota</a> were not as <a href="https://lore.kernel.org/lkml/202105051005.49BFABCE@keescook/">successful</a> as one might assume.</p>
<p>Now that we have the brief overview, let me go further in detail on the process.</p>
<h2 id="the-kernel-development-process">The Kernel Development Process<a hidden class="anchor" aria-hidden="true" href="#the-kernel-development-process">#</a></h2>
<p>This section will just be a very brief summary of the Linux development process. For further reading, please consult the <a href="https://www.kernel.org/doc/html/latest/process/2.Process.html">official documentation</a>.</p>
<h3 id="the-kernel-release-cycle">The Kernel Release Cycle<a hidden class="anchor" aria-hidden="true" href="#the-kernel-release-cycle">#</a></h3>
<p>The kernel uses a rolling development model. At the beginning of each development cycle, the merge window is opened. This is when maintainers forward feature patches to Linus. The bulk of major changes for a new development cycle will be merged during this time.</p>
<p>The merge window lasts for approximately two weeks. At the end of this time, Linus Torvalds will declare that the window is closed and release the first of the “rc” kernels. For the kernel destined to be v6.16 (current kernel as of the time of writing), this would be designated as v6.16-rc1. The -rc1 release is the signal that the time to merge new features has passed, and that the time to stabilize the next kernel has begun.</p>
<p>Over the next six to ten weeks, only bug fix patches should be submitted to the mainline. As fixes make their way into the mainline, the patch rate will slow over time. Linus releases new -rc kernels about once a week; a normal series will get up to somewhere between -rc6 and -rc9 before the kernel is considered to be sufficiently stable and the final release is made.</p>
<p>The most significant metric used to determine if the kernel is stable enough is the list of regressions from previous releases. At that point the whole process starts over again.</p>
<h3 id="how-patches-get-into-the-kernel">How Patches get into the Kernel<a hidden class="anchor" aria-hidden="true" href="#how-patches-get-into-the-kernel">#</a></h3>
<p>The kernel code base is logically broken down into subsystems: networking, memory management, drm, etc.</p>
<p>Most subsystems have designated maintainer(s), developer(s) who has/have the overall responsibility for the code within that subsystem.</p>
<p>These subsystem maintainers are the gatekeepers for the portion of the kernel they manage; they are the ones who will accept a patch for inclusion into the mainline kernel.</p>
<p>When the merge window opens, the top-level maintainers will ask Linus to “pull” the patches they have selected for merging from their repositories.</p>
<p>With that info in mind, let&rsquo;s see how a patch is created and mailed.</p>
<hr>
<h2 id="configuration">Configuration<a hidden class="anchor" aria-hidden="true" href="#configuration">#</a></h2>
<h3 id="smtp-configuration">SMTP Configuration<a hidden class="anchor" aria-hidden="true" href="#smtp-configuration">#</a></h3>
<p>Please refer to this <a href="https://support.google.com/accounts/answer/185833?hl=en">link</a> to setup an app password.</p>
<p>This password will be necessary when sending the mail with git send-email.</p>
<p>You could use a non Google SMTP server but I do not know how they work.</p>
<h3 id="git-configuration">Git Configuration<a hidden class="anchor" aria-hidden="true" href="#git-configuration">#</a></h3>
<p>Before starting, I would highly suggest you to configure your git username and email via</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git config user.name <span style="color:#e6db74">&#34;Your Name&#34;</span>
</span></span><span style="display:flex;"><span>git config user.email <span style="color:#e6db74">&#34;your.email@example.com&#34;</span>
</span></span></code></pre></div><p>You can check the config with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git config user.name  <span style="color:#75715e"># Prints user.name</span>
</span></span><span style="display:flex;"><span>git config user.email <span style="color:#75715e"># Prints user.email</span>
</span></span></code></pre></div><p>After you are setup with the configuration, clone Linus&rsquo; repo. You can do this via</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git <span style="color:#75715e"># Linus&#39; copy (mainline)</span>
</span></span></code></pre></div><h2 id="creating-the-patch">Creating the patch<a hidden class="anchor" aria-hidden="true" href="#creating-the-patch">#</a></h2>
<p>Make the required changes and commit it, having the commit messages adhere to this format:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>subsystem: brief summary of the change
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Then add a blank line, followed by a detailed explanation of the change. 
</span></span></code></pre></div><p>This is important because the first line will become the subject of the mail you will be sending.</p>
<p>You can check commits that have touched the file you want to understand what the commit should look like. This is done via:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git log -- &lt;file-name&gt;
</span></span></code></pre></div><p>See <a href="https://www.kernel.org/doc/html/latest/process/submitting-patches.html">SubmittingPatches</a> for more details.</p>
<p>When you are about to commit, add the -s flag to the command. This adds a Signed-off-by line at the end of the commit.</p>
<p>This is required as per <a href="https://developercertificate.org/">Developer Certificate of Origin</a>.</p>
<p>Assuming you have made n commits, create the patches by running</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git format-patch HEAD~n
</span></span></code></pre></div><p>A single patch should contain one logical change.</p>
<p>After creating the patch(es), verify that it/they satisfies/satisfy the patch standards by running</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#e6db74">${</span>LINUX_BASE<span style="color:#e6db74">}</span>/scripts/checkpatch.pl <span style="color:#e6db74">${</span>PATCH<span style="color:#e6db74">}</span> <span style="color:#75715e"># do this for each patch in case of a patch series</span>
</span></span></code></pre></div><p>Note that your patch(es) should be as tested as thoroughly as possible if code was modified.</p>
<p>I won&rsquo;t be covering that aspect in this article.</p>
<h2 id="mailing-the-patch">Mailing the patch<a hidden class="anchor" aria-hidden="true" href="#mailing-the-patch">#</a></h2>
<p>You need to figure out to whom the patch(es) need to be mailed to by running:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#e6db74">${</span>LINUX_BASE<span style="color:#e6db74">}</span>/scripts/get_maintainer.pl <span style="color:#e6db74">${</span>FILE_MODIFIED<span style="color:#e6db74">}</span>
</span></span></code></pre></div><p>With that knowledge, It should be time to mail them.</p>
<p>Keep in mind that the Linux Kernel Mailing Lists (lkml) expect you to mail in plaintext format which needs some <a href="https://support.google.com/mail/answer/8260?hl=en&amp;co=GENIE.Platform%3DDesktop">setup</a>. If you don&rsquo;t do that, your mail will be rejected like this:</p>
<p><img alt="Diagram showing Rejection" loading="lazy" src="/posts/linux/linux_upstream/rejection.png"></p>
<p>I wouldn&rsquo;t recommend mailing patches via Gmail directly.</p>
<p>Git provides a dedicated command — <code>git send-email</code> — for sending emails in plain-text format.</p>
<p>You should use git send-email like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git send-email --to<span style="color:#f92672">=</span>&lt;MAINTAINER-1&gt; --to<span style="color:#f92672">=</span>&lt;MAINTAINER-2&gt; ... --cc<span style="color:#f92672">=</span>&lt;LIST-1&gt; ... patch/patches
</span></span></code></pre></div><p>This is the most basic command for mailing patches.</p>
<p>After a maintainer takes interest in your patch, they add it to Patchwork which is where you can track the progress of your patch.</p>
<p>Patchwork is a web-based patch tracking system that helps maintainers and contributors track the status of submitted patches, from review to acceptance and merging.</p>
<p>Here&rsquo;s how my attempts went.</p>
<hr>
<h1 id="my-attempts">My attempts<a hidden class="anchor" aria-hidden="true" href="#my-attempts">#</a></h1>
<p>Mailing a patch is just the beginning; You need to convince the maintainer that the patch is correct and necessary.</p>
<p>It&rsquo;s a rather long process, and it&rsquo;s quite common for you to get ghosted without warning if your patch isn&rsquo;t proper which is what happened to me.</p>
<h2 id="attempt-1">Attempt 1<a hidden class="anchor" aria-hidden="true" href="#attempt-1">#</a></h2>
<p>This was my <a href="https://lore.kernel.org/kernel-janitors/20250215085817.2455-1-viswanathiyyappan@gmail.com/">patch</a>.</p>
<p>I threw in a second smaller patch because I believed that was just a free patch.</p>
<p>I sent it there because I thought that’s where newbies sent their patches. And I was very wrong.</p>
<p>I was thankfully redirected to <a href="mailto:linux-i2c@vger.kernel.org">linux-i2c@vger.kernel.org</a> by one of the maintainers.</p>
<p>I then submitted the patch <a href="https://lore.kernel.org/linux-i2c/20250218131039.1344-1-viswanathiyyappan@gmail.com/">there</a> and waited.</p>
<h2 id="attempt-2">Attempt 2<a hidden class="anchor" aria-hidden="true" href="#attempt-2">#</a></h2>
<p>Three months passed by and I realized that my patch would not be picked up.</p>
<p>So, It was time to go back to the drawing board. One of the first things I suspected was the subject of the patch.</p>
<p>The issue was “[PATCH] i2c: Update i2c_msg documentation to clarify write” was just too vague; That did not specify what exactly was changed. So, my solution was to change the title to “i2c: Clarify behavior of I2C_M_RD flag”. Here’s the submitted patch</p>
<p>This actually caught the attention of the maintainer and he was willing to accept it, if I signed with my legal name. I re-sent it almost immediately but then I made a really dumb mistake.</p>
<h2 id="attempt-3">Attempt 3<a hidden class="anchor" aria-hidden="true" href="#attempt-3">#</a></h2>
<p>The thing is I sent the <a href="https://lore.kernel.org/linux-i2c/20250519235657.7404-1-viswanathiyyappan@gmail.com/">patch</a> with improper threading.</p>
<p>Without the correct reply-to, the patch will not show up in the thread making it hard to understand the conversation.</p>
<p>So, After a few months of waiting, I realized something was wrong and realized my mistake.</p>
<p>Here’s what the new command after adding reply-to looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git send-email --in-reply-to<span style="color:#f92672">=</span>aCtgNpWs1tJ1FltB@shikoro --to<span style="color:#f92672">=</span>wsa+renesas@sang-engineering.com --cc<span style="color:#f92672">=</span>linux-i2c@vger.kernel.org --cc<span style="color:#f92672">=</span>viswanathiyyappan@gmail.com MY_REPLY
</span></span></code></pre></div><p>If you click the reply hyperlink below a message, it actually provides you with the command</p>
<p><img alt="Diagram showing Reply" loading="lazy" src="/posts/linux/linux_upstream/reply.png"></p>
<p>This led me to create my penultimate <a href="https://lore.kernel.org/linux-i2c/20250709150203.7199-1-viswanathiyyappan@gmail.com/">patch</a>.</p>
<p>I made a mistake missing the subject in the cover letter and corrected it <a href="https://lore.kernel.org/linux-i2c/20250709151402.7811-1-viswanathiyyappan@gmail.com/">here</a> which was accepted.</p>
<p><a href="https://patchwork.ozlabs.org/project/linux-i2c/patch/20250709151402.7811-2-viswanathiyyappan@gmail.com/">Here</a> is my final accepted patch. The commit id for this patch in upstream is c3ff7f06c787</p>
<hr>
<h1 id="closing-remarks">Closing Remarks<a hidden class="anchor" aria-hidden="true" href="#closing-remarks">#</a></h1>
<p>This particular patch is very minor compared to a bug fix or a feature patch. But this was good enough for a first patch.</p>
<p>To be clear, It usually does not take months to get a patch (especially of this complexity) in. I just didn&rsquo;t know what I was doing.</p>
<p>In a way, getting your first patch in is the hardest.</p>
<p>I hope this article has shed some light on the Linux contribution process and helped clarify things. Here are references for further reading:</p>
<ul>
<li><a href="https://kernelnewbies.org/">Kernel Newbies</a></li>
<li><a href="https://docs.kernel.org/">Kernel Documentation</a></li>
<li><a href="https://trainingportal.linuxfoundation.org/learn/course/a-beginners-guide-to-linux-kernel-development-lfd103/">Beginners Guide to Kernel Development</a></li>
</ul>
<p>The course explains the contribution process much better than this article.</p>
<p>I would also suggest participating in the Linux Kernel Mentorship Program (<a href="https://wiki.linuxfoundation.org/lkmp">https://wiki.linuxfoundation.org/lkmp</a>) if this was interesting to you.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://craftychimera.github.io/">Portfolio</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
